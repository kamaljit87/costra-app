# Build backend & frontend, push to ECR, SSH to node(s) and redeploy via k3s.
#
# Required secrets:
#   AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY  – ECR push + node ECR pull
#   SSH_PRIVATE_KEY, SSH_HOST                 – deploy via SSH
#   VITE_GOOGLE_CLIENT_ID                     – baked into frontend at build time
#
# SSH_HOST: one IP/hostname, or comma-separated for multiple nodes.

name: Build, Push to ECR, and Deploy

on:
  push:
    branches: [main]
  workflow_dispatch:

concurrency:
  group: build-deploy-${{ github.ref }}
  cancel-in-progress: false

env:
  AWS_REGION: us-east-1
  ECR_REGISTRY: 005878674861.dkr.ecr.us-east-1.amazonaws.com
  ECR_BACKEND: 005878674861.dkr.ecr.us-east-1.amazonaws.com/costra-backend
  ECR_FRONTEND: 005878674861.dkr.ecr.us-east-1.amazonaws.com/costra-frontend
  REMOTE_DIR: /var/servers/costra-app
  REMOTE_USER: ubuntu
  REMOTE_PORT: "44823"
  K8S_NAMESPACE: costra

jobs:
  build-and-push:
    name: Build and push to ECR
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      image_tag: ${{ steps.meta.outputs.image_tag }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify Dockerfiles exist
        run: |
          test -f Dockerfile.backend || { echo "::error::Dockerfile.backend not found"; exit 1; }
          test -f Dockerfile.frontend || { echo "::error::Dockerfile.frontend not found"; exit 1; }

      - name: Set image tag
        id: meta
        run: echo "image_tag=$(echo ${{ github.sha }} | cut -c1-7)" >> $GITHUB_OUTPUT

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create ECR repositories if missing
        run: |
          for repo in costra-backend costra-frontend; do
            aws ecr describe-repositories --repository-names "$repo" --region ${{ env.AWS_REGION }} 2>/dev/null || \
              aws ecr create-repository --repository-name "$repo" --region ${{ env.AWS_REGION }}
          done

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push backend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.backend
          push: true
          tags: |
            ${{ env.ECR_BACKEND }}:latest
            ${{ env.ECR_BACKEND }}:${{ steps.meta.outputs.image_tag }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.frontend
          push: true
          tags: |
            ${{ env.ECR_FRONTEND }}:latest
            ${{ env.ECR_FRONTEND }}:${{ steps.meta.outputs.image_tag }}
          build-args: |
            VITE_API_URL=/api
            VITE_GOOGLE_CLIENT_ID=${{ secrets.VITE_GOOGLE_CLIENT_ID }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: false

  deploy:
    name: Deploy to k3s via SSH
    needs: build-and-push
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Install SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

      - name: Checkout (deploy script + k8s manifests)
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            scripts
            k8s

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Pull and save images
        env:
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        run: |
          docker pull "$ECR_BACKEND:$IMAGE_TAG"
          docker pull "$ECR_FRONTEND:$IMAGE_TAG"
          docker save "$ECR_BACKEND:$IMAGE_TAG" | gzip > /tmp/backend.tar.gz
          docker save "$ECR_FRONTEND:$IMAGE_TAG" | gzip > /tmp/frontend.tar.gz

      - name: Deploy to each node
        env:
          REMOTE_HOST: ${{ secrets.SSH_HOST }}
          IMAGE_TAG: ${{ needs.build-and-push.outputs.image_tag }}
        run: |
          if [ -z "$REMOTE_HOST" ]; then
            echo "::warning::SSH_HOST not set; skipping deploy."
            exit 0
          fi
          PORT="${{ env.REMOTE_PORT }}"
          USER="${{ env.REMOTE_USER }}"
          DIR="${{ env.REMOTE_DIR }}"
          NS="${{ env.K8S_NAMESPACE }}"
          REGISTRY="${{ env.ECR_REGISTRY }}"
          TAG="$IMAGE_TAG"
          SSH="ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=accept-new -p $PORT"
          SCP="scp -i ~/.ssh/deploy_key -P $PORT"
          for HOST in $(echo "$REMOTE_HOST" | tr ',' ' '); do
            [ -z "$HOST" ] && continue
            echo "::group::Deploying to $HOST"
            ssh-keyscan -p "$PORT" -H "$HOST" >> ~/.ssh/known_hosts 2>/dev/null || true

            # Ensure sparse checkout is configured on the server
            $SSH "$USER@$HOST" "cd $DIR && git sparse-checkout set k8s scripts 2>/dev/null || true"

            echo "Transferring images and manifests..."
            $SCP /tmp/backend.tar.gz /tmp/frontend.tar.gz scripts/k8s-deploy.sh "$USER@$HOST:/tmp/"
            # Sync k8s manifests to the server
            $SCP -r k8s "$USER@$HOST:$DIR/"

            echo "Importing images into k3s..."
            $SSH "$USER@$HOST" "gunzip -c /tmp/backend.tar.gz | sudo k3s ctr images import - && gunzip -c /tmp/frontend.tar.gz | sudo k3s ctr images import - && bash /tmp/k8s-deploy.sh $REGISTRY $NS $TAG $DIR"
            echo "::endgroup::"
          done
